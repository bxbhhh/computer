### 组成原理--201组实验报告
---
#### 冲突处理  
* 数据冲突  
    实验中，我们遇到的数据冲突主要体现在**读后写**、**写后读**等问题上，其中，由于实现的是五级流水的流水线结构，上一条指令和这一条中如果使用了相同的寄存器，并且前一条指令涉及访存操作，便容易出现神奇的bug。在参考借鉴了老师上课讲的思路之后，我们得出了以下两点解决办法：  

    * 首先，我们将问题分为两种，一种是两条数据冲突的指令，中间有其他的不造成新的数据冲突的指令作为间隔。这时，可以通过老师上课讲的**Forwording**思路来解决，数据旁路可以完美地解决这一类数据冲突。
    * 其次，对于第一点无法解决的冲突，我们在实验中遇到的bug是，两条造成数据出冲突的指令正好在时间上是相邻的。这时，数据旁路由于延迟的原因，无法解决。通过小组成员的讨论和查阅书籍，我们找到了另一种和第一种互补的思路。即数据前推。具体来说：
      ​    * 当一条指令运行到EX阶段，将计算的结果返回给ID阶段。
      ​         * 当一条指令运行到MEM阶段，将准备要写入寄存器的值也传回ID阶段。
      ​             * 在ID阶段对比前两条指令传回的寄存器编号和寄存器值，检查上一条指令是否会影响这一条指令要使用的寄存器。如果会，则通过多路选择器进行选择。最终确定正确的寄存器值。 

* 结构冲突  

    本次实验中遇到的最大的结构冲突，就是关于取指和访存的冲突。由于32位板子只能使用一片RAM，无法做到数据和指令分开存储。因此，在设计数据通路时，我们对一开始简单的指令数据分开存储的想法，进行了修改和完善。最终得出的解决方案是：

    * 首先由于这一结构冲突的发生时间具有非常大的不确定性，同时，又非常致命。在没有更好的稳定方案的情况下，我们采用了插入气泡的方法来解决这一冲突。
    * 在总线bus中，所有关于访存的相关操作中，遵循先取指后访存的原则。
    * 每次取指之前，MEM模块向控制器发送一个stall信号，请求在取指阶段之后插入一个气泡。

* 控制冲突    

    * 我们组遇到的控制冲突主要是：//增加

        跳转指令带来的冲突。跳转指令在ID阶段才能得到需要跳转的指令，在EX阶段才能真正知道是否要跳转。

#### 异常和中断的实现  

* 需要增加的指令mtc0, mfc0的分析：  
  * 通过阅读要求文档，我们初步确定了实现异常和中断的思路：
    * 需要修改流水线以适应协处理器相关的指令，具体为mtc0、mfc0.
    * 需要增加协处理器cp0这一部件，并实现其中的部分寄存器。  
  * 实现mtc0、mfc0指令，在原有的基础版本的基础上，修改了各个阶段。具体包括：
    * ID阶段增加对这两条指令的判断。  
    * ID阶段读寄存器的值时，如果当前指令为协处理器指令，则寄存器的值从协处理器中读取。
    * EX阶段增加对mfc0指令的数据前推支持，思路同处理数据冲突时一样。
    * MEM阶段，增加对mfc0的数据前推支持，解决相关的数据冲突。
    * WB阶段，对写回寄存器的值进行处理，如果当前指令为mtc0,那么将值写入到协处理器中对应的寄存器。  

* 增加协处理器cp0,用来协助异常处理  

  * 在协处理器中，具体实现了下面这些寄存器：

    ```vhdl
        output reg[`RegBus]           data_o,
        output reg[`RegBus]           count_o,
        output reg[`RegBus]           compare_o,
        output reg[`RegBus]           status_o,
        output reg[`RegBus]           cause_o,
        output reg[`RegBus]           epc_o,
        output reg[`RegBus]           config_o,
        output reg[`RegBus]           prid_o,
    ```

* 根据异常发生的指令的顺序而不是异常顺序来处理异常  

  这一点在设计数据通路的过程中，小组成员就进行过讨论，之后发现这是一个前人解决过得问题，进一步进行了完善。

  * 首先，由于实现的是流水线结构，因此正常情况下流水线上都应该运行着五条指令，因此，不管什么时候产生异常，都必须考虑到其他指令的执行情况，与之后异常处理结束之后的程序能否继续正常执行的情况。

  * 因此，我们考虑对在流水线上的五条指令进行一个分类，

    * 在异常发生指令之前进入流水线的指令，应该在异常处理前被执行完毕，成功写回寄存器和内存。

    * 在异常指令之后进入流水线的指令，应该避免其执行带来的影响，做到就像它从未进入流水线一样。
  * 最终，我们的做法是，//增加

